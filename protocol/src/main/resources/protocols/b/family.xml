<protocol-family name="type-b" script="java">
    <header>
        <length type="varint" />
        <id type="varint" />
    </header>
    <types>
        <type name="boolean" provides="boolean">
            <read>
                return `read` != 0;
            </read>
            <write>
                `write {`value` ? 1 : 0}`;
            </write>
        </type>
		<type name="byte" provides="byte">
			<read>
				return (byte) `read`;
			</read>
			<write>
				`write `value``;
			</write>
		</type>
		<type name="ubyte" provides="int">
			<read>
				return `read`;
			</read>
			<write>
				`write `value``;
			</write>
		</type>
		<type name="short" provides="short">
			<read><![CDATA[
				int i1 = `read`;
				int i2 = `read`;
				return (short) ((i1 << 8) + (i2));
			]]></read>
			<write><![CDATA[
				`write `(value >>> 8) & 0xFF`;
				`write `(value)       & 0xFF`;
			]]></write>
		</type>
		<type name="ushort" provides="int">
			<read><![CDATA[
				int i1 = `read`;
				int i2 = `read`;
				return (i1 << 8) + (i2);
			]]></read>
			<write><![CDATA[
			    `write {(value >>> 8) & 0xFF}`;
			    `write {(value      ) & 0xFF}`;
			]]></write>
		</type>
		<type name="int" provides="int">
			<read><![CDATA[
				int[] buffer = new int[4];
			    `read-array buffer 0 4`;
				return ((buffer[0] & 0xFF) << 24)
				     + ((buffer[1] & 0xFF) << 16)
				     + ((buffer[2] & 0xFF) <<  8)
				     + ((buffer[3] & 0xFF)      );
			]]></read>
			<write><![CDATA[
				int[] buffer = new int[4];
			    buffer[0] = (byte) ((value >>> 24) & 0xFF);
				buffer[1] = (byte) ((value >>> 16) & 0xFF);
				buffer[2] = (byte) ((value >>>  8) & 0xFF);
				buffer[3] = (byte) ((value       ) & 0xFF);
				`write-array buffer 0 4`;
			]]></write>
		</type>
		<type name="uint" provides="long">
			<read><![CDATA[
				int[] buffer = new int[4];
				`read-array buffer 0 4`;
			    return ((buffer[0] & 0xFF) << 24)
			         + ((buffer[1] & 0xFF) << 16)
			         + ((buffer[2] & 0xFF) <<  8)
			         + ((buffer[3] & 0xFF)      );
			]]></read>
			<write><![CDATA[
				int[] buffer = new int[4];
			    buffer[0] = (byte) ((value >>> 24) & 0xFF);
			    buffer[1] = (byte) ((value >>> 16) & 0xFF);
			    buffer[2] = (byte) ((value >>>  8) & 0xFF);
			    buffer[3] = (byte) ((value       ) & 0xFF);
			    `write-array buffer 0 4`;
			]]></write>
		</type>
		<type name="long" provides="long">
			<read><![CDATA[
				int[] buffer = new int[8];
				`read-array buffer 0 8`;
				return ((buffer[0] & 0xFFL) << 56)
				     + ((buffer[1] & 0xFFL) << 48)
				     + ((buffer[2] & 0xFFL) << 40)
				     + ((buffer[3] & 0xFFL) << 32)
				     + ((buffer[4] & 0xFFL) << 24)
				     + ((buffer[5] & 0xFFL) << 16)
				     + ((buffer[6] & 0xFFL) <<  8)
				     + ((buffer[7] & 0xFFL)      );
			]]></read>
			<write><![CDATA[
				int[] buffer = new int[8];
			    buffer[0] = (byte) ((value >>> 56) & 0xFF));
			    buffer[1] = (byte) ((value >>> 48) & 0xFF));
			    buffer[2] = (byte) ((value >>> 40) & 0xFF));
			    buffer[3] = (byte) ((value >>> 32) & 0xFF));
			    buffer[4] = (byte) ((value >>> 24) & 0xFF));
			    buffer[5] = (byte) ((value >>> 16) & 0xFF));
			    buffer[6] = (byte) ((value >>>  8) & 0xFF));
			    buffer[7] = (byte) ((value       ) & 0xFF));
			    `write-array buffer 0 8`;
			]]></write>
		</type>
		<type name="float" provides="float">
			<read><![CDATA[
				return Float.intBitsToFloat(`read int`);
			]]></read>
			<write><![CDATA[
				`write int Float.floatToIntBits(`value`))`;
			]]></write>
		</type>
		<type name="double" provides="double">
			<read><![CDATA[
				return Double.longBitsToDouble(`read long`);
			]]></read>
			<write><![CDATA[
				write("long", Double.doubleToLongBits(value));
			]]></write>
		</type>
		<type name="varint" provides="int">
			<read><![CDATA[
				int varint = 0;
				for(int i = 0; i < 5; i++) {
					int b = `read`;
					if(i == 4 && (b & 0xF0) != 0)
						error("Varint too big");
						
					varint |= (b & 0x7F) << (i * 7);
					if((b & 0x80) == 0)
						break;
				}
				return varint;
			]]></read>
			<write><![CDATA[
				for(int varint = `value`; varint != 0; varint >>>= 7)
					write(((varint >>> 7) != 0 ? 0x80 : 0x00) | (varint & 0x7F));
			]]></write>
		</type>
		<type name="varlong" provides="long">
			<read><![CDATA[
				long varlong = 0;
				for(int i = 0; i < 10; i++) {
					int b = `read`;
					if(i == 9 && (b & 0xF0) != 0)
						error("Varlong too big");
						
					varlong |= ((long) b & 0x7F) << (i * 7);
					if((b & 0x80) == 0)
						break;
				}
				return varlong;
			]]></read>
			<write><![CDATA[
				for(long varlong = `value`; varlong != 0; varlong >>>= 7)
					`write {((varlong >>> 7) != 0 ? 0x80 : 0x00) | (varlong & 0x7F)}`;
			]]></write>
		</type>
		<type name="string" provides="java.lang.String">
			<options>
				<option name="limit" type="int" default="32767" />
				<option name="trim" type="boolean" default="false" />
			</options>
			<variables>
				<variable name="utf8" type="java.util.Charset">
					return Charset.forName("UTF-8");
				</variable>
			</variables>
			<imports>
				<import class="java.util.Charset" />
			</imports>
			<read><![CDATA[
				int limit = `option limit`;
				boolean trim = `option trim`;
				
				int length = `read varint`;
				`read-array buffer 0 length`;
				String string = new String(buffer, 0, length, `variable utf8`);
				
				if(string.length() > limit) {
					if(trim)
						string = string.substring(0, limit);
					else
						error("String too big: " + string.length() + " > " + limit);
				}
				
				return string;
			]]></read>
			<write><![CDATA[
				int limit = `option limit`;
				boolean trim = `option trim`;
				String string = `value`;
				
			    if(string.length() > limit) {
			    	if(trim)
			    		string = string.substring(0, limit);
			    	else
			    		error("String too big: " + string.length() + " > " + limit);
			    }
			    
			    byte[] bytes = string.getBytes(`variable utf8`);
			    `write varint {bytes.length}`;
			    `write-array bytes 0 bytes.length`;
			]]></write>
		</type>
		<type name="fixed-point" provides="float">
			<options>
				<option name="divisor" type="int" default="32" />
			</options>
			<read><![CDATA[
				int div = `option divisor`;
				return `read` / (float) div;
			]]></read>
			<write><![CDATA[
				int div = `option divisor`;
				`write {(int) (`value` * div)}`;
			]]></write>
		</type>
	</types>
</protocol-family>